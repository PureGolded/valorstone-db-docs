{% extends 'base.html' %}
{% block meta %}
  {% if is_shared %}
    <meta property="og:title" content="Shared Folder" />
    <meta property="og:description" content="Browse shared documents." />
  {% endif %}
{% endblock %}
{% block content %}
<div class="row space-between">
  <div class="row" style="gap:.5rem; align-items:center;">
    <a class="btn" href="{{ ('/s/f/' + share.id) if share else '/workspace' }}"><i class="ri-arrow-left-line"></i> Back</a>
    <h1>Documents</h1>
  </div>
  {% if can_edit %}
  <div class="row" style="gap:.5rem;">
    <button id="newFolderBtn" class="btn" title="Create folder"><i class="ri-folder-add-line"></i> New Folder</button>
    <button id="newDocBtn" class="btn primary" title="Create document"><i class="ri-file-add-line"></i> New Document</button>
  </div>
  {% endif %}
</div>
{% if share %}
<p class="note">Shared view. {% if not can_edit %}Read-only.{% endif %}</p>
{% endif %}

<div class="stack">
  <div class="card">
    <div class="row space-between">
      <h2>All Files & Folders</h2>
      <div class="row" style="gap:.5rem;">
        <button class="btn icon" title="Expand all" onclick="expandAll()"><i class="ri-arrow-down-s-line"></i></button>
        <button class="btn icon" title="Collapse all" onclick="collapseAll()"><i class="ri-arrow-right-s-line"></i></button>
        {% if can_edit %}
        <button class="btn icon" title="Share root" onclick="shareRoot()"><i class="ri-link"></i></button>
        {% endif %}
      </div>
    </div>
    <div id="docs-tree" class="docs-tree"></div>
  </div>
</div>
{% endblock %}
{% block scripts %}
<script>
const CAN_EDIT = JSON.parse('{{ can_edit|default(false)|tojson }}');
const IS_SHARED = JSON.parse('{{ is_shared|default(false)|tojson }}');
const SHARE = JSON.parse('{{ share|default(None)|tojson }}');

function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }

async function fetchState(){
  const url = IS_SHARED ? (`/api/shared/f/${SHARE.id}/state`) : '/api/docs/state';
  const r = await fetch(url);
  const j = await r.json();
  if (!j.ok) throw new Error('Failed to load docs');
  return j;
}

function buildIndex(state){
  const folders = state.folders || {};
  const docs = state.documents || {};
  const byParent = {};
  const ensure = (pid)=>{ if(!byParent[pid]) byParent[pid] = []; return byParent[pid]; };
  const folderIds = new Set(Object.keys(folders));
  const roots = [];
  // collect children
  for (const f of Object.values(folders)){
    if (f.parent_id && folderIds.has(f.parent_id)) ensure(f.parent_id).push({...f, type:'folder'}); else roots.push({...f, type:'folder'});
  }
  for (const d of Object.values(docs)){
    if (d.parent_id && folderIds.has(d.parent_id)) ensure(d.parent_id).push({...d, type:'doc'}); else roots.push({...d, type:'doc'});
  }
  const sorter = (a,b)=> (a.type===b.type? a.name.localeCompare(b.name) : (a.type==='folder'?-1:1));
  for (const k of Object.keys(byParent)) byParent[k].sort(sorter);
  roots.sort(sorter);
  return {folders, docs, byParent, roots};
}

function renderTree(idx){
  const root = document.getElementById('docs-tree');
  root.innerHTML = '';
  const ul = document.createElement('ul');
  ul.className = 'tree-root';
  root.appendChild(ul);

  function nodeRow(icon, name, controls){
    const row = document.createElement('div');
    row.className = 'node-row';
    const ic = document.createElement('span'); ic.className='icon'; ic.innerHTML = icon; row.appendChild(ic);
    const nameSpan = Object.assign(document.createElement('span'), {className:'name'});
    nameSpan.textContent = name;
    row.appendChild(nameSpan);
    if (controls) row.appendChild(controls);
    return row;
  }

  function actions(buttons){
    const wrap = document.createElement('div');
    wrap.className = 'actions row';
    for (const b of buttons){ wrap.appendChild(b); }
    return wrap;
  }

  function btn(label, cls, onClick, title){
    const b = document.createElement('button');
    b.className = 'btn '+(cls||''); b.innerHTML = label; if(title) b.title = title; b.addEventListener('click', onClick); return b;
  }

  function renderFolder(f){
    const li = document.createElement('li'); li.className = 'node folder';
  const twisty = document.createElement('span'); twisty.className='twisty'; twisty.innerHTML = '<i class="ri-arrow-right-s-line"></i>';
    twisty.addEventListener('click', ()=> li.classList.toggle('expanded'));
  const header = document.createElement('div'); header.className = 'node-header';
  header.appendChild(twisty);
    // title and name
    const nameWrap = document.createElement('div'); nameWrap.className = 'node-row';
  const fIcon = document.createElement('span'); fIcon.className='icon'; fIcon.innerHTML = '<i class="ri-folder-2-line"></i>'; nameWrap.appendChild(fIcon);
    const nameSpan = Object.assign(document.createElement('span'), {className:'name'});
    nameSpan.textContent = f.name;
    nameWrap.appendChild(nameSpan);
    header.appendChild(nameWrap);
    // action icons (left group)
    if (CAN_EDIT){
      const left = actions([
        btn('<i class="ri-pencil-line"></i>','', ()=> renameFolder(f.id), 'Rename'),
        btn('<i class="ri-drag-move-2-line"></i>','', ()=> moveFolder(f.id), 'Move'),
        btn('<i class="ri-link"></i>','', ()=> shareFolder(f.id), 'Share'),
        btn('<i class="ri-delete-bin-6-line"></i>','danger', ()=> deleteFolder(f.id), 'Delete'),
      ]);
      left.classList.add('left');
      header.appendChild(left);
      // create group (right)
      const create = actions([
        btn('<i class="ri-folder-add-line"></i>','', ()=> newFolder(f.id), 'Create folder inside'),
        btn('<i class="ri-file-add-line"></i>','primary', ()=> newDoc(f.id), 'Create document inside'),
      ]);
      create.classList.add('create');
      header.appendChild(create);
    }
    // toggle expand when clicking anywhere on header except buttons/links/twisty
    header.addEventListener('click', (ev)=>{
      if (ev.target.closest('button,.actions,.doc-link,.twisty')) return;
      li.classList.toggle('expanded');
    });
    li.appendChild(header);
    const kids = document.createElement('ul'); kids.className = 'children';
    const list = idx.byParent[f.id] || [];
    for (const ch of list){ kids.appendChild(renderNode(ch)); }
    li.appendChild(kids);
    return li;
  }

  function renderDoc(d){
    const li = document.createElement('li'); li.className = 'node doc';
    const link = IS_SHARED ? `/s/f/${SHARE.id}/d/${d.id}` : `/docs/d/${d.id}`;
    // Build a header-like row to align with folders: placeholder twisty + content
    const header = document.createElement('div'); header.className = 'node-header';
    const placeholder = document.createElement('span'); placeholder.className = 'twisty placeholder'; placeholder.innerHTML = '<i class="ri-arrow-right-s-line"></i>';
    header.appendChild(placeholder);
    const a = document.createElement('a'); a.href = link; a.className = 'doc-link';
    const row = nodeRow('<i class="ri-file-text-line"></i>', d.name, null);
    const updated = document.createElement('span'); updated.className = 'note'; updated.style.marginLeft = '.5rem';
    if (d.updated_at){ updated.textContent = new Date(d.updated_at*1000).toLocaleString(); }
    row.appendChild(updated);
    if (CAN_EDIT){
      const left = actions([
        btn('<i class="ri-pencil-line"></i>','', (ev)=>{ ev.preventDefault(); renameDoc(d.id); }, 'Rename'),
        btn('<i class="ri-drag-move-2-line"></i>','', (ev)=>{ ev.preventDefault(); moveDoc(d.id); }, 'Move'),
        btn('<i class="ri-link"></i>','', (ev)=>{ ev.preventDefault(); shareDoc(d.id); }, 'Share'),
        btn('<i class="ri-delete-bin-6-line"></i>','danger', (ev)=>{ ev.preventDefault(); deleteDoc(d.id); }, 'Delete'),
      ]);
      row.appendChild(left);
    }
    a.appendChild(row);
    header.appendChild(a);
    li.appendChild(header);
    return li;
  }

  function renderNode(item){ return item.type==='folder'? renderFolder(item) : renderDoc(item); }

  for (const r of idx.roots){ ul.appendChild(renderNode(r)); }
}

let DOCS_STATE = null; let DOCS_INDEX = null;

function modalInput(title, fields, onSubmit){
  const form = Modal.inputs(fields);
  Modal.open({ title, body: form, actions: [ {label:'Cancel'}, {label:'Save', className:'primary', onClick: async ()=>{ const v = form.getValues(); return await onSubmit(v) !== false; }} ] });
}

async function newFolder(parent_id=null){
  modalInput('Create Folder', [{key:'name', label:'Folder name', type:'text', value:''}], async ({name})=>{
    if (!name) return false;
    const res = await fetch('/api/docs/folders', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name, parent_id})});
    if (res.ok){ boot(); }
  });
}
async function newDoc(parent_id=null){
  modalInput('Create Document', [{key:'name', label:'Document name', type:'text', value:''}], async ({name})=>{
    if (!name) return false;
    const res = await fetch('/api/docs', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name, parent_id})});
    if (res.ok){ boot(); }
  });
}
async function renameFolder(id){
  const f = DOCS_STATE.folders[id];
  modalInput('Rename Folder', [{key:'name', label:'Folder name', type:'text', value:f.name}], async ({name})=>{
    if (!name) return false;
    await fetch(`/api/docs/folders/${id}`, {method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name})});
    boot();
  });
}
async function renameDoc(id){
  const d = DOCS_STATE.documents[id];
  modalInput('Rename Document', [{key:'name', label:'Document name', type:'text', value:d.name}], async ({name})=>{
    if (!name) return false;
    await fetch(`/api/docs/${id}`, {method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name})});
    boot();
  });
}

function chooseFolderModal({title, excludeIds=[]}={}){
  return new Promise(async (resolve)=>{
    const wrap = document.createElement('div');
    wrap.className = 'stack';
    const info = document.createElement('p'); info.className = 'note'; info.textContent = 'Choose a destination folder (or Root).'; wrap.appendChild(info);
    const list = document.createElement('div'); wrap.appendChild(list);
    const radio = (id, label)=>{ const d = document.createElement('div'); d.className='row'; const i=document.createElement('input'); i.type='radio'; i.name='dest'; i.value=id; const l=document.createElement('label'); l.textContent=label; d.appendChild(i); d.appendChild(l); return {wrap:d, input:i}; };
    const opts = [];
    // Root option
    const rootOpt = radio('', 'Root'); list.appendChild(rootOpt.wrap); opts.push(rootOpt.input);
    // Build a simple tree listing with indentation
    function addFolder(id, level){
      if (excludeIds.includes(id)) return; const f = DOCS_STATE.folders[id]; if (!f) return;
      const pad = '\u00A0'.repeat(level*2);
      const r = radio(id, pad + f.name); list.appendChild(r.wrap); opts.push(r.input);
      const children = DOCS_INDEX.byParent[id] || [];
      for (const ch of children){ if (ch.type==='folder'){ addFolder(ch.id, level+1); } }
    }
    // roots
    for (const r of DOCS_INDEX.roots){ if (r.type==='folder') addFolder(r.id, 0); }
    Modal.open({ title: title||'Move to Folder', body: wrap, actions:[ {label:'Cancel'}, {label:'Move', className:'primary', onClick: ()=>{ const sel = opts.find(o=>o.checked); resolve(sel && sel.value ? sel.value : null); return true; } } ] });
  });
}

async function moveFolder(id){
  // Exclude self and its descendants
  const exclude = [id];
  const stack = [id];
  while (stack.length){ const x = stack.pop(); const kids = (DOCS_INDEX.byParent[x]||[]).filter(k=>k.type==='folder'); for (const k of kids){ exclude.push(k.id); stack.push(k.id); } }
  const dest = await chooseFolderModal({title:'Move Folder', excludeIds: exclude});
  if (dest === undefined) return; // cancelled
  await fetch(`/api/docs/folders/${id}`, {method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({parent_id: dest})});
  boot();
}

async function moveDoc(id){
  const dest = await chooseFolderModal({title:'Move Document'});
  if (dest === undefined) return;
  await fetch(`/api/docs/${id}`, {method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({parent_id: dest})});
  boot();
}

async function deleteFolder(id){
  const body = document.createElement('div'); body.innerHTML = '<p>Delete this folder? It must be empty.</p>';
  Modal.open({ title:'Delete Folder', body, actions:[ {label:'Cancel'}, {label:'Delete', className:'danger', onClick: async()=>{ const res = await fetch(`/api/docs/folders/${id}`, {method:'DELETE'}); if (!res.ok){ alert('Folder not empty'); return false; } boot(); return true; } } ] });
}

async function deleteDoc(id){
  const body = document.createElement('div'); body.innerHTML = '<p>Delete this document?</p>';
  Modal.open({ title:'Delete Document', body, actions:[ {label:'Cancel'}, {label:'Delete', className:'danger', onClick: async()=>{ await fetch(`/api/docs/${id}`, {method:'DELETE'}); boot(); return true; } } ] });
}

async function shareDoc(id){
  const res = await fetch(`/api/docs/${id}/share`, {method:'POST'}); const j = await res.json();
  if (j.ok){
    const body = document.createElement('div');
    body.innerHTML = `<div class="field"><span>Share URL</span><input type="text" value="${j.url}" readonly onclick="this.select()"/></div>`;
    Modal.open({ title:'Share Document', body, actions:[ {label:'Close'}, {label:'Copy', className:'primary', onClick: ()=>{ navigator.clipboard.writeText(j.url); return true; } } ] });
  }
}
async function shareFolder(id){
  const res = await fetch(`/api/docs/folders/${id}/share`, {method:'POST'}); const j = await res.json();
  if (j.ok){
    const body = document.createElement('div');
    body.innerHTML = `<div class="field"><span>Share URL</span><input type="text" value="${j.url}" readonly onclick="this.select()"/></div>`;
    Modal.open({ title:'Share Folder', body, actions:[ {label:'Close'}, {label:'Copy', className:'primary', onClick: ()=>{ navigator.clipboard.writeText(j.url); return true; } } ] });
  }
}
async function shareRoot(){ alert('To share, open a specific folder and use Share. Root sharing is not available yet.'); }

async function boot(){
  try{
    DOCS_STATE = await fetchState();
    DOCS_INDEX = buildIndex(DOCS_STATE);
    renderTree(DOCS_INDEX);
  } catch (e){ console.error(e); const root = document.getElementById('docs-tree'); root.textContent = 'Failed to load.'; }
}

document.addEventListener('DOMContentLoaded', ()=>{
  const fBtn = document.getElementById('newFolderBtn');
  const dBtn = document.getElementById('newDocBtn');
  if (fBtn) fBtn.addEventListener('click', ()=> newFolder(null));
  if (dBtn) dBtn.addEventListener('click', ()=> newDoc(null));
  boot();
});

function expandAll(){ document.querySelectorAll('#docs-tree li.folder').forEach(li=> li.classList.add('expanded')); }
function collapseAll(){ document.querySelectorAll('#docs-tree li.folder').forEach(li=> li.classList.remove('expanded')); }
</script>
{% endblock %}
